<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Entity Relationship]]></title>
    <url>%2F2018%2F12%2F14%2FInfo%2Fentitry_relationship%2F</url>
    <content type="text"><![CDATA[Entity Relationship 1234567891011121314151617181920212223@Entity@Data //lombokpublic class Student &#123; @Id @GeneratedValue( strategy = GenerationType.IDENTITY) private Long studentId; private String studentName; private int studentAge; private boolean enable = true; @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinColumn(name = "studentId") List&lt;Course&gt; courses = new ArrayList&lt;&gt;(); public void addCourse(Course course) &#123; this.courses.add(course); &#125;&#125; 12345678910111213@Entity@Data //lombokpublic class Course implements &#123; @Id @GeneratedValue( strategy = GenerationType.IDENTITY) private Long courseId; private String courseName; private boolean enable = true;&#125; 이렇게 Entity관계가 형성되어있다고 했을 때 INSERT, UPDATE, DELETE하는 방법 INSERT 12345678910111213141516171819202122Student student = new Student();student.setStudentName("홍길동");student.setStudentAge(17);List&lt;Course&gt; courses = new ArrayList&lt;&gt;();Course korean = new Course();korean.setCourseName("국어");courses.add(korean);Course mathematics = new Course();mathematics.setCourseName("수학");courses.add(mathematics);Course english = new Course();english.setCourseName("영어");courses.add(english);student.addAll(courses);studentRepository.save(student); UPDATE 12345678910111213141516171819public class StudentDto &#123; @Getter @Setter public static class Update &#123; private Long studentId; private String studentName; private int studentAge; private boolean enable = true; List&lt;Course&gt; courses = new ArrayList&lt;&gt;(); &#125; public static class UpdateStuentPropertyMap extends PropertyMap&lt;StudentDto.Update, Student&gt; &#123; @Override protected void configure() &#123; skip(destination.getCourses()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void udpateStudent(StudentDto.Update update) &#123; Student student = studentRepository.findById(update.getStudentId()); ModelMapper modelMapper = new ModelMapper(); // 잘못된 예 // modelmapper.map(update, student); /* 현재 Student의 Entity안에 Course라고하는 Entity가 List형태로 관계맺어져있는데 parent되는 Student의 경우 modelmapper가 제대로 동작하여 해당 데이터를 매핑해주지만 내부의 Course List는 jpa의 session문제 및 count가 같은경우 맵핑이 제대로 동작하지 않는등의 문제가 있다. 해서 해당의 경우는 PropertyMap등을 통하여 맵핑에서 제외하고 별도의 맵핑작업이 필요하다. */ modelMapper.addMappings(new StudentDto.UpdateStuentPropertyMap()); // 위에 Dto에 만들어놓은 propertyMap을 사용하도록 modelmapper.map(update, student); // 위에 선언된 PropertyMap의 configure에 따라서 courses는 스킵된다. // Course를 DELETE후 INSERT하는 예 student.getCourses().clear(); student.getCourses().addAll(update.getCourses()); // Course를 DELETE후 INSERT하는 예 // Course를 비교하여 INSERT, UPDATE, DELETE하는 방법 for (Course course: update.getCourses()) &#123; // INSERT // update로 들어온 object의 id가 null인 경우 기존의 것이 아닌 새로운 데이터로 판단 및 약속하여 insert처리한다. if (course.getStudentId() == null) &#123; student.addCourse(course); continue; &#125; // UPDATE // 기존의 id와 같은 데이터가 들어오는 경우 내부에는 데이터의 변경이 일어났을 수 있으므로 mapping해준다. for (Course originCourse: student.getCourses()) &#123; if (originCourse.getCourseId().equals(course.getCourseId())) &#123; modelmapper.map(course, originCourse); &#125; &#125; &#125; // DELETE // for문에서 해당 데이터를 remove하는것은 index등을 신경써야 하는 부분이 많으므로 따로 분리하여 처리한다. Iterator&lt;Course&gt; courseIterator = student.getCourses().iterator(); while (courseIterator.hasNext()) &#123; Course course = courseIterator.next(); if (!containsCourseId(course, update.getCourses())) &#123; courseIterator.remove(); &#125; &#125; // Course를 비교하여 INSERT, UPDATE, DELETE하는 방법 studentRepository.save(student);&#125;private boolean containsCourseId(Course course, List&lt;Course&gt; updateCourses) &#123; // org.apache.commons.collections4.CollectionUtils if (CollectionUtils.isNotEmpty(updateCourses)) &#123; for (Course updateCourse: updateCourses) &#123; if (updateCourse.getCourseId() == null) &#123; return true; &#125; if (updateCourse.getCourseId() != null &amp;&amp; updateCourse.getCourseId().equals(course.getCourseId())) &#123; return true; &#125; &#125; &#125; return false;&#125; DELETE 1234private void deleteStudent(Long studentId) &#123; Student student = studentRepository.findById(studentId); studentRepository.delete(student);&#125;]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA Repository Entity안의 List형태 Entity접근]]></title>
    <url>%2F2018%2F12%2F11%2FInfo%2Fjpa_repository_grammer%2F</url>
    <content type="text"><![CDATA[JPA Repository에서 Entity안의 List형태 Entity에 접근하여 조건을 거는 방법 12345678910111213141516171819@Entity@Data //lombokpublic class Student &#123; @Id @GeneratedValue( strategy = GenerationType.IDENTITY) private Long studentId; private String studentName; private int studentAge; private boolean enable = true; @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL) @JoinColumn(name = "studentId") List&lt;Course&gt; courses = new ArrayList&lt;&gt;();&#125; 12345678910111213@Entity@Data //lombokpublic class Course &#123; @Id @GeneratedValue( strategy = GenerationType.IDENTITY) private Long courseId; private String courseName; private boolean enable = true; &#125; 1234@Repositorypublic interface StudentRepository extends JpaRepository&lt;Student, Long&gt; &#123; Student findByCourses_CourseId(Long courseId);&#125; IDE에서 자동완성 기능을 사용할 때 위의 문법은 자동완성에는 표시되지 않는다. 하지만 Entity간의 접근은 &#39;_&#39;로 구분되어 표현이 가능하고 해당 Entitry에 접근하는 것에도 문제가 없다. 나중에는 고민하지 말고 쓰자!]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
</search>
